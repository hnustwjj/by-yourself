/**
桃子装箱
时间限制： 3000MS
内存限制： 589824KB
题目描述：
小昱家的桃园丰收了！小昱采摘下来n个桃子，并对这些桃子称重，其中第i个桃子的重量为ai。
小昱想选择一些桃子装成一箱后送给朋友，但是小昱不希望一箱桃子中有一些太大的桃子而影响整体美观。
于是他给装箱工人提出了一个要求：一箱桃子中最重的桃子重量不能超过平均重量的k倍。
装箱工人想知道在满足小昱要求的情况下，一箱最多能装多少个桃子。



输入描述
第一行输入两个正整数 n, k，表示桃子个数、倍数系数。

接下来一行输入n个正整数a1, a2,...... an，其中ai表示第 i 个桃子的重量。


1 ≤ n, k ≤ 100000, 1≤ ai ≤ 109

输出描述
输出一个整数，表示一箱最多能装桃子数量。


样例输入
5 2
3 10 5 4 2
样例输出
4

提示
可以将第1、3、4、5个桃子装成一箱，桃子平均重量为(3 + 5 + 4 + 2) / 4 = 3.5，最重的桃子重量为5，不超过平均重量的两倍，是一种可行方案。

如果将所有桃子装成一箱，桃子平均重量为(3 + 10 + 5 + 4 + 2) / 5 = 4.8，最重桃子的重量为10，超过平均重量的两倍了，故一箱不能装5个桃子。
 */

const [n, k] = [6, 2];
let arr = [3, 10, 5, 4, 2, 10];
arr = arr.sort((a, b) => a - b);
//  1，2，3
// 总的平均数计算：0 * (0 / 1) + 1 * (1 / 1) = 1
//                 1 * (1 / 2) + 2 * (1 / 2) = 1.5
//                 1.5 * (2 / 3) + 3 * (1 / 3) = 2
let pjs = arr.reduce((p, n, index) => {
  return p * (index / (index + 1)) + n * (1 / (index + 1));
}, 0);

// 平均数褪去计算：(2 - 3 * (1/3)) * (1 + (1 / 2)) = 1.5
//                (1.5 - 2 * (1 / 2)) * (1+1) = 1
while (pjs * k <= arr[arr.length - 1]) {
  const len = arr.length;
  const num = arr.pop();
  pjs = (pjs - num * (1 / len)) * (1 + 1 / (len - 1));
}
console.log(arr.length);
