/**
 对于每个结点，左孩子都比当前结点小，右孩子都比当前结点大
 n : 1 
               1
 n : 2  
               1         2
                \       /
                 2     1 
 n : 3
               1           1             2                3      3
                \           \           / \              /      /  
                 2           3         1   3            2      1
                  \         /                          /        \
                   3       2                          1          2


    仔细观察，当n=3时，以1为root，它的右子树的结构和n=2时一样，左子树的结构和n=0时一样
                      以2为root，它的左右子树的结构都和n=1时一样
                      以3位root，它的左子树的结构和n=2时一样，右子树的结构和n=0时一样
    
    dp[i] 是 i个元素能组成的二叉搜索树的个数
    初值dp[0] = 1 dp[1] = 1
    推导公式：
      dp[3] = dp[2]*dp[0] + dp[1]*dp[1] + dp[0]*dp[2]
      ...
 */
var numTrees = function (n) {
  const dp = new Array(n + 1).fill(0);
  dp[0] = 1;
  dp[1] = 1;
  for (let i = 2; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      dp[i] += dp[j - 1] * dp[i - j];
    }
  }
  return dp[n];
};
